#!/bin/bash
echo '''
8""""8                                                                             88                                                            
8    8 e  eeeee eeeee eeeee eeeee eeee eeeeeee eeeee  e   e    e    eeeee e  eeeee  8 eeeee    eeeee    eeeee  eeee eeeee e   e eeee eeeee eeeee 
8e   8 8  8   " 8   8 8   " 8   " 8    8  8  8 8   8  8   8    8    8   8 8  8   8      8      8   8    8   8  8    8   8 8   8 8    8   "   8   
88   8 8e 8eeee 8eee8 8eeee 8eeee 8eee 8e 8  8 8eee8e 8e  8eeee8    8eee8 8e 8e  8      8e     8eee8    8eee8e 8eee 8   8 8e  8 8eee 8eeee   8e  
88   8 88    88 88  8    88    88 88   88 8  8 88   8 88    88      88  8 88 88  8      88     88  8    88   8 88   8 __8 88  8 88      88   88  
88eee8 88 8ee88 88  8 8ee88 8ee88 88ee 88 8  8 88eee8 88eee 88      88  8 88 88  8      88     88  8    88   8 88ee 8e888 88ee8 88ee 8ee88   88  
                                                                                                                                                 
'''
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# --- COLORS ---
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# --- DEPENDENCY DEFINITIONS ---
REQUIRED_TOOLS=(
    "file:file"              # File type detection
    "strings:binutils"       # String extraction
    "xxd:xxd"                # Hex dump
)

OPTIONAL_TOOLS=(
    "checksec:checksec.sh"   # Security feature checker
    "readelf:binutils"       # ELF parser
    "nm:binutils"            # Symbol table reader
    "ldd:libc-bin"           # Dynamic library lister
    "getcap:libcap2-bin"     # Linux capabilities
    "objdump:binutils"       # Disassembler
)

# --- ENHANCED DEPENDENCY CHECK ---
check_dependencies() {
    local missing_required=()
    local missing_optional=()
    local all_good=true
    
    echo -e "${BLUE}[*] Checking dependencies...${NC}"
    
    # Check required tools
    for entry in "${REQUIRED_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_required+=("$tool ($package)")
            all_good=false
        fi
    done
    
    # Check optional tools
    for entry in "${OPTIONAL_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_optional+=("$tool ($package)")
        fi
    done
    
    # Report results
    if [ "$all_good" = true ] && [ ${#missing_optional[@]} -eq 0 ]; then
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
        return 0
    fi
    
    if [ ${#missing_required[@]} -gt 0 ]; then
        echo -e "${RED}[✗] MISSING REQUIRED DEPENDENCIES:${NC}"
        printf '%s\n' "${missing_required[@]}" | sed 's/^/    /'
        
        # Extract unique packages
        local packages=()
        for entry in "${REQUIRED_TOOLS[@]}"; do
            IFS=':' read -r tool package <<< "$entry"
            if ! command -v "$tool" &>/dev/null; then
                packages+=("$package")
            fi
        done
        packages=($(printf '%s\n' "${packages[@]}" | sort -u))
        
        echo -e "\n${YELLOW}Install with:${NC}"
        echo -e "    ${BOLD}sudo apt install ${packages[*]}${NC}\n"
        exit 1
    fi
    
    if [ ${#missing_optional[@]} -gt 0 ]; then
        echo -e "${YELLOW}[!] Missing optional tools (limited functionality):${NC}"
        printf '%s\n' "${missing_optional[@]}" | sed 's/^/    /'
        
        # Extract unique packages
        local opt_packages=()
        for entry in "${OPTIONAL_TOOLS[@]}"; do
            IFS=':' read -r tool package <<< "$entry"
            if ! command -v "$tool" &>/dev/null; then
                opt_packages+=("$package")
            fi
        done
        opt_packages=($(printf '%s\n' "${opt_packages[@]}" | sort -u))
        
        echo -e "\n${CYAN}Install with:${NC}"
        echo -e "    ${BOLD}sudo apt install ${opt_packages[*]}${NC}\n"
    else
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
    fi
}

# Run dependency check first
check_dependencies

# --- ARGUMENT PARSING ---
FILE="$1"

if [ -z "$FILE" ]; then
    echo -e "${RED}Usage: $0 <binary_file>${NC}"
    echo "Example: $0 /bin/ls"
    exit 1
fi

if [ ! -f "$FILE" ]; then
    echo -e "${RED}[!] File not found: $FILE${NC}"
    exit 1
fi

echo -e "${BLUE}[*] Scouting binary: ${BOLD}$FILE${NC}\n"

# --- CACHE FILE TYPE (call once, reuse) ---
FILE_TYPE=$(file -b "$FILE")
FILE_TYPE_MIME=$(file -b --mime-type "$FILE")
echo -e "${CYAN}    Type: ${YELLOW}$FILE_TYPE${NC}"

# --- PARALLEL TOOL EXECUTION ---
TMP_DIR="/tmp/binscout_$$"
mkdir -p "$TMP_DIR"
trap "rm -rf $TMP_DIR" EXIT

run_parallel_analysis() {
    # Run checksec in background
    if command -v checksec &>/dev/null; then
        checksec --file="$FILE" > "$TMP_DIR/checksec.txt" 2>&1 &
    elif command -v checksec.sh &>/dev/null; then
        checksec.sh --file="$FILE" > "$TMP_DIR/checksec.txt" 2>&1 &
    fi
    
    # Run nm in background (if ELF)
    if echo "$FILE_TYPE" | grep -q "ELF"; then
        if command -v nm &>/dev/null; then
            nm "$FILE" > "$TMP_DIR/nm.txt" 2>&1 &
        fi
        
        # Run readelf in background
        if command -v readelf &>/dev/null; then
            readelf -h "$FILE" > "$TMP_DIR/readelf_header.txt" 2>&1 &
            readelf -l "$FILE" > "$TMP_DIR/readelf_program.txt" 2>&1 &
            readelf -s "$FILE" > "$TMP_DIR/readelf_symbols.txt" 2>&1 &
        fi
        
        # Run ldd in background
        if command -v ldd &>/dev/null; then
            ldd "$FILE" > "$TMP_DIR/ldd.txt" 2>&1 &
        fi
    fi
    
    # Wait for all background jobs
    wait
}

# Launch parallel analysis
run_parallel_analysis &
PARALLEL_PID=$!

# --- SECURITY PROTECTIONS ---
echo
echo -e "${BLUE}[*] Security Protections${NC}"

# Wait for parallel jobs to complete
wait $PARALLEL_PID

if [ -f "$TMP_DIR/checksec.txt" ]; then
    cat "$TMP_DIR/checksec.txt"
else
    # Manual check for ELF
    if command -v readelf &>/dev/null && echo "$FILE_TYPE" | grep -q "ELF"; then
        echo -e "${YELLOW}    (Manual ELF check - install checksec for full analysis)${NC}"
        
        # NX Check
        if [ -f "$TMP_DIR/readelf_program.txt" ]; then
            if grep -q "GNU_STACK" "$TMP_DIR/readelf_program.txt"; then
                if grep "GNU_STACK" "$TMP_DIR/readelf_program.txt" | grep -q "RWE"; then
                    echo -e "    NX: ${RED}Disabled (Stack Executable)${NC}"
                else
                    echo -e "    NX: ${GREEN}Enabled${NC}"
                fi
            fi
        fi
        
        # PIE Check
        if [ -f "$TMP_DIR/readelf_header.txt" ]; then
            if grep "Type:" "$TMP_DIR/readelf_header.txt" | grep -q "EXEC"; then
                echo -e "    PIE: ${RED}No (Position Dependent)${NC}"
            elif grep "Type:" "$TMP_DIR/readelf_header.txt" | grep -q "DYN"; then
                echo -e "    PIE: ${GREEN}Yes (PIE/Shared Object)${NC}"
            fi
        fi
        
        # Canary Check
        if [ -f "$TMP_DIR/nm.txt" ]; then
            if grep -q "__stack_chk_fail" "$TMP_DIR/nm.txt"; then
                echo -e "    Canary: ${GREEN}Found${NC}"
            else
                echo -e "    Canary: ${RED}Not Found${NC}"
            fi
        fi
    fi
fi

# --- PACKER DETECTION ---
echo
echo -e "${BLUE}[*] Detecting Packers${NC}"

# Use ripgrep if available (10x faster), fallback to grep
if command -v rg &>/dev/null; then
    if rg -a "UPX!" "$FILE" &>/dev/null; then
        echo -e "    ${RED}[!] UPX Packed Detected!${NC}"
        echo -e "    ${CYAN}Unpack: upx -d $FILE -o ${FILE}_unpacked${NC}"
    else
        echo "    No obvious UPX signature found"
    fi
else
    if strings "$FILE" | grep -q "UPX!"; then
        echo -e "    ${RED}[!] UPX Packed Detected!${NC}"
        echo -e "    ${CYAN}Unpack: upx -d $FILE -o ${FILE}_unpacked${NC}"
    else
        echo "    No obvious UPX signature found"
    fi
fi

# --- STRING PREVIEW (optimized - use head for speed) ---
echo
echo -e "${BLUE}[*] Interesting Strings Preview${NC}"
strings -n 6 "$FILE" 2>/dev/null | head -n 15
echo "    ..."

# --- ARCHITECTURE & TOOLS ---
echo
echo -e "${BLUE}[*] Recommended Tools${NC}"

if echo "$FILE_TYPE" | grep -q "ELF"; then
    # Enhanced architecture detection
    ARCH=$(echo "$FILE_TYPE" | grep -oE "x86-64|Intel 80386|ARM|MIPS|PowerPC|RISC-V|SPARC|AArch64")
    [ -z "$ARCH" ] && ARCH="Unknown"
    
    echo "    - Architecture: ${BOLD}$ARCH${NC}"
    echo "    - Decompiler:   Ghidra / IDA Pro / Binary Ninja"
    echo "    - Debugger:     GDB (gef/pwndbg) / EDB"
    echo "    - Analysis:     radare2 / rizin"
    
elif echo "$FILE_TYPE" | grep -q "PE32"; then
    if echo "$FILE_TYPE" | grep -q "x86-64"; then
        ARCH="x64"
    else
        ARCH="x86"
    fi
    echo "    - Architecture: ${BOLD}$ARCH${NC}"
    echo "    - Decompiler:   Ghidra / IDA Pro"
    echo "    - Debugger:     x64dbg / OllyDbg / WinDbg"
    echo "    - Static:       PE-bear / CFF Explorer / pestudio"
    
elif echo "$FILE_TYPE" | grep -q "Java"; then
    echo "    - Decompiler:   jd-gui / jadx / CFR"
    
elif echo "$FILE_TYPE" | grep -q "Python script"; then
    echo "    - Source:       Just read it!"
elif echo "$FILE_TYPE" | grep -q "Python" && echo "$FILE_TYPE" | grep -q "byte"; then
    echo "    - Decompiler:   uncompyle6 / decompyle3 / pycdc"
fi

# --- DYNAMIC LIBRARY DEPENDENCIES (ELF only) ---
if echo "$FILE_TYPE" | grep -q "ELF" && [ -f "$TMP_DIR/ldd.txt" ]; then
    echo
    echo -e "${BLUE}[*] Dynamic Library Dependencies${NC}"
    
    if grep -q "not a dynamic executable" "$TMP_DIR/ldd.txt"; then
        echo "    ${BOLD}Statically linked binary (No libc dependency)${NC}"
    else
        cat "$TMP_DIR/ldd.txt" | while read -r line; do
            echo "    $line"
            
            # Highlight libc for ret2libc attacks
            if echo "$line" | grep -q "libc.so"; then
                LIBC_PATH=$(echo "$line" | grep -oE '/[^ ]+libc[^ ]+')
                if [ -n "$LIBC_PATH" ] && [ -f "$LIBC_PATH" ]; then
                    echo -e "    ${YELLOW}[!] Libc found: $LIBC_PATH${NC}"
                    
                    # GLIBC Version Detection
                    LIBC_VER=$($LIBC_PATH 2>&1 | head -1 | grep -oE '[0-9]+\.[0-9]+' || echo "")
                    if [ -n "$LIBC_VER" ]; then
                        echo -e "    ${GREEN}    GLIBC Version: $LIBC_VER${NC}"
                        
                        # Suggest heap techniques based on version
                        case "$LIBC_VER" in
                            2.2[7-9]|2.3[0-9])
                                echo -e "    ${CYAN}    Heap: Tcache poisoning, House of Einherjar${NC}"
                                ;;
                            2.2[3-6])
                                echo -e "    ${CYAN}    Heap: Fastbin dup, Unsorted bin attack${NC}"
                                ;;
                            *)
                                echo -e "    ${CYAN}    Heap: Classic unlink, House of Force${NC}"
                                ;;
                        esac
                    fi
                    
                    # Extract system() offset
                    if command -v readelf &>/dev/null; then
                        SYSTEM_ADDR=$(readelf -s "$LIBC_PATH" 2>/dev/null | grep " system@@" | awk '{print $2}')
                        if [ -n "$SYSTEM_ADDR" ]; then
                            echo -e "    ${YELLOW}    system() offset: 0x$SYSTEM_ADDR${NC}"
                        fi
                    fi
                fi
            fi
        done
    fi
fi

# --- CRYPTO CONSTANT DETECTION (optimized with limited read) ---
echo
echo -e "${BLUE}[*] Cryptographic Constant Detection${NC}"

# Read only first 64KB for speed
HEX_DATA=$(xxd -s 0 -l 65536 -p "$FILE" 2>/dev/null | tr -d '\n')

if [ -n "$HEX_DATA" ]; then
    # MD5 constants
    if echo "$HEX_DATA" | grep -qi "67452301efcdab89"; then
        echo -e "    ${YELLOW}[!] MD5 constants detected${NC}"
        echo "        Likely uses standard MD5 implementation"
    fi
    
    # AES S-box
    if echo "$HEX_DATA" | grep -qi "637c777bf26b6fc5"; then
        echo -e "    ${YELLOW}[!] AES S-box constants detected${NC}"
        echo "        Likely uses standard AES implementation"
    fi
    
    # SHA-256
    if echo "$HEX_DATA" | grep -qi "428a2f98d728ae22"; then
        echo -e "    ${YELLOW}[!] SHA-256 constants detected${NC}"
        echo "        Likely uses standard SHA-256 implementation"
    fi
    
    # Check strings for crypto library usage
    if strings "$FILE" 2>/dev/null | grep -qiE "(openssl|libcrypto|libssl|mbedtls|wolfssl)"; then
        CRYPTO_LIB=$(strings "$FILE" 2>/dev/null | grep -iE "(openssl|libcrypto|libssl|mbedtls|wolfssl)" | head -1)
        echo -e "    ${GREEN}[+] Crypto library: $CRYPTO_LIB${NC}"
    fi
else
    echo "    Could not scan for crypto constants"
fi

# --- SECCOMP SANDBOX DETECTION ---
if echo "$FILE_TYPE" | grep -q "ELF"; then
    echo
    echo -e "${BLUE}[*] Seccomp Sandbox Analysis${NC}"
    
    if strings "$FILE" 2>/dev/null | grep -qi "seccomp"; then
        echo -e "    ${YELLOW}[!] Seccomp references found${NC}"
        
        if command -v seccomp-tools &>/dev/null; then
            echo "    Run: seccomp-tools dump $FILE"
        else
            echo -e "    ${CYAN}Install: gem install seccomp-tools${NC}"
        fi
    else
        echo "    No seccomp detected"
    fi
fi

# --- LINUX CAPABILITIES ---
if echo "$FILE_TYPE" | grep -q "ELF"; then
    echo
    echo -e "${BLUE}[*] Linux Capabilities Analysis${NC}"
    
    if command -v getcap &>/dev/null; then
        CAPS=$(getcap "$FILE" 2>/dev/null)
        
        if [ -n "$CAPS" ]; then
            echo -e "    ${RED}[!!!] CAPABILITIES DETECTED:${NC}"
            echo "    $CAPS"
            
            # Highlight dangerous capabilities
            echo "$CAPS" | grep -qi "cap_setuid" && echo -e "    ${YELLOW}[!] CAP_SETUID: Privilege escalation!${NC}"
            echo "$CAPS" | grep -qi "cap_setgid" && echo -e "    ${YELLOW}[!] CAP_SETGID: GID manipulation${NC}"
            echo "$CAPS" | grep -qi "cap_dac_override" && echo -e "    ${YELLOW}[!] CAP_DAC_OVERRIDE: Bypass file permissions${NC}"
            echo "$CAPS" | grep -qi "cap_sys_admin" && echo -e "    ${YELLOW}[!] CAP_SYS_ADMIN: System administration${NC}"
            echo "$CAPS" | grep -qi "cap_net_raw" && echo -e "    ${YELLOW}[!] CAP_NET_RAW: Raw socket access${NC}"
        else
            echo "    No capabilities set"
        fi
    else
        echo "    getcap not available (install libcap2-bin)"
    fi
fi

# --- RPATH/RUNPATH HIJACKING ---
if echo "$FILE_TYPE" | grep -q "ELF"; then
    echo
    echo -e "${BLUE}[*] RPATH/RUNPATH Hijacking Analysis${NC}"
    
    if command -v readelf &>/dev/null; then
        RPATH_DATA=$(readelf -d "$FILE" 2>/dev/null | grep -E "RPATH|RUNPATH")
        
        if [ -n "$RPATH_DATA" ]; then
            echo -e "    ${YELLOW}[!] Dynamic library search paths:${NC}"
            echo "$RPATH_DATA" | sed 's/^/    /'
            
            # Check for dangerous paths
            if echo "$RPATH_DATA" | grep -qE "RPATH.*[\[\.]"; then
                echo -e "    ${RED}[!!!] RELATIVE RPATH - VULNERABLE!${NC}"
                echo -e "    ${CYAN}Exploit: LD_PRELOAD or malicious .so in current dir${NC}"
            fi
            
            if echo "$RPATH_DATA" | grep -qE "RUNPATH.*[\[\.]"; then
                echo -e "    ${RED}[!!!] RELATIVE RUNPATH - VULNERABLE!${NC}"
            fi
        else
            echo "    No RPATH/RUNPATH set"
        fi
    fi
fi

echo
echo -e "${GREEN} Triage Complete${NC}"

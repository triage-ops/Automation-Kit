#!/usr/bin/env bash

echo '''
8   8                                    8""8""8                                         8"""88                           
8   8 eeeee eeeee e   e    e eeeee       8  8  8 eeeee eeeee eeee e   e    e eeeee       8    8 e   e  e eeeee    e eeeee 
8eee8 8   8 8   " 8   8    8   8         8e 8  8 8   8   8   8  8 8   8    8   8         8    8 8   8  8 8   8    8   8   
88  8 8eee8 8eeee 8eee8    8e  8e        88 8  8 8eee8   8e  8e   8eee8    8e  8e        8    8 8e  8  8 8e  8    8e  8e  
88  8 88  8    88 88  8    88  88        88 8  8 88  8   88  88   88  8    88  88        8    8 88  8  8 88  8    88  88  
88  8 88  8 8ee88 88  8    88  88  88    88 8  8 88  8   88  88e8 88  8    88  88  88    8eeee8 88ee8ee8 88  8    88  88  
                                                                                                                          
'''

set -euo pipefail

# --- COLORS ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m'

# --- DEPENDENCY DEFINITIONS ---
REQUIRED_TOOLS=(
    "grep:grep"
    "base64:coreutils"
)

OPTIONAL_TOOLS=(
    "curl:curl"
    "jq:jq"
    "hashcat:hashcat"
)

# --- DEPENDENCY CHECK ---
check_dependencies() {
    local missing_required=()
    local missing_optional=()
    local all_good=true
    
    echo -e "${BLUE}[*] Checking dependencies...${NC}"
    
    for entry in "${REQUIRED_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_required+=("$tool ($package)")
            all_good=false
        fi
    done
    
    for entry in "${OPTIONAL_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_optional+=("$tool ($package)")
        fi
    done
    
    if [ "$all_good" = true ] && [ ${#missing_optional[@]} -eq 0 ]; then
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
        return 0
    fi
    
    if [ ${#missing_required[@]} -gt 0 ]; then
        echo -e "${RED}[✗] MISSING REQUIRED DEPENDENCIES:${NC}"
        printf '%s\n' "${missing_required[@]}" | sed 's/^/    /'
        
        local packages=()
        for entry in "${REQUIRED_TOOLS[@]}"; do
            IFS=':' read -r tool package <<< "$entry"
            if ! command -v "$tool" &>/dev/null; then
                packages+=("$package")
            fi
        done
        packages=($(printf '%s\n' "${packages[@]}" | sort -u))
        
        echo -e "\n${YELLOW}Install with:${NC}"
        echo -e "    ${BOLD}sudo apt install ${packages[*]}${NC}\n"
        exit 1
    fi
    
    if [ ${#missing_optional[@]} -gt 0 ]; then
        echo -e "${YELLOW}[!] Missing optional tools (limited functionality):${NC}"
        printf '%s\n' "${missing_optional[@]}" | sed 's/^/    /'
        echo -e "${CYAN}(curl: online lookups, jq: JSON parsing, hashcat: local cracking)${NC}\n"
    else
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
    fi
}

check_dependencies

# --- INPUT HANDLING ---
if [ "$#" -ge 1 ]; then
    if [ -f "$1" ]; then
        INPUT_DATA=$(cat "$1")
    else
        INPUT_DATA="$1"
    fi
else
    if [ -t 0 ]; then
        echo -e "${RED}Usage: $0 <hash_string_or_file>${NC}"
        echo "Example: $0 5f4dcc3b5aa765d61d8327deb882cf99"
        exit 1
    fi
    INPUT_DATA=$(cat)
fi

INPUT=$(echo "$INPUT_DATA" | xargs)
LEN=${#INPUT}

echo -e "${BLUE}[*] Analyzing string (length: $LEN)${NC}\n"

# --- HASH VALIDATION ---
validate_hash() {
    local hash="$1"
    local len=${#hash}
    
    # Check if hex (for standard hashes)
    if [[ "$hash" =~ ^[0-9a-fA-F]+$ ]]; then
        # Validate common lengths
        case $len in
            32|40|48|56|64|96|128) return 0 ;;
            *) echo -e "${YELLOW}[!] Unusual hex length: $len${NC}" >&2; return 1 ;;
        esac
    fi
    return 0
}

# --- CACHE SYSTEM ---
CACHE_DIR="/tmp/hash_detector_cache"
mkdir -p "$CACHE_DIR"

get_cached_result() {
    local hash="$1"
    local hash_md5=$(echo -n "$hash" | md5sum 2>/dev/null | cut -d' ' -f1)
    local cache_file="$CACHE_DIR/$hash_md5"
    
    if [ -f "$cache_file" ]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
        # Cache valid for 24 hours
        if [ $cache_age -lt 86400 ]; then
            cat "$cache_file"
            return 0
        fi
    fi
    return 1
}

save_to_cache() {
    local hash="$1"
    local result="$2"
    local hash_md5=$(echo -n "$hash" | md5sum 2>/dev/null | cut -d' ' -f1)
    echo "$result" > "$CACHE_DIR/$hash_md5"
}

# --- ONLINE HASH LOOKUP (with retry backoff) ---
online_lookup() {
    local hash="$1"
    
    # Check cache first
    if cached_result=$(get_cached_result "$hash"); then
        echo -e "${CYAN}[i] Using cached result${NC}"
        echo "$cached_result"
        return 0
    fi
    
    if ! command -v curl &>/dev/null; then
        echo -e "${YELLOW}[i] curl not available - skipping online lookup${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}[*] Attempting online hash lookup...${NC}"
    
    local retry_count=0
    local max_retries=3
    
    while [ $retry_count -lt $max_retries ]; do
        # Try hashes.com
        local result=$(curl -s --max-time 10 "https://hashes.com/en/api/identifier" -d "hash=$hash" 2>/dev/null || echo "")
        
        if [ -n "$result" ]; then
            if command -v jq &>/dev/null; then
                # Use jq for proper JSON parsing
                local plaintext=$(echo "$result" | jq -r '.plaintext // empty' 2>/dev/null)
                if [ -n "$plaintext" ]; then
                    save_to_cache "$hash" "$plaintext"
                    echo -e "${GREEN}[!!!] HASH CRACKED: $plaintext${NC}"
                    return 0
                fi
            else
                # Fallback grep method
                if echo "$result" | grep -q "FOUND"; then
                    local cracked=$(echo "$result" | grep -oP '"plaintext":"\K[^"]+' || echo "")
                    if [ -n "$cracked" ]; then
                        save_to_cache "$hash" "$cracked"
                        echo -e "${GREEN}[!!!] HASH CRACKED: $cracked${NC}"
                        return 0
                    fi
                fi
            fi
            break
        fi
        
        # Exponential backoff
        retry_count=$((retry_count + 1))
        [ $retry_count -lt $max_retries ] && sleep $((2 ** retry_count))
    done
    
    # Try md5decrypt.net for MD5
    if [ "$LEN" -eq 32 ]; then
        local web_result=$(curl -s --max-time 10 "https://md5decrypt.net/en/Api/api.php?hash=$hash&hash_type=md5&email=dehasher@gmail.com&code=1122334455" 2>/dev/null || echo "")
        if [ -n "$web_result" ] && [ "$web_result" != "NOT FOUND" ] && [ "$web_result" != "ERROR" ]; then
            save_to_cache "$hash" "$web_result"
            echo -e "${GREEN}[!!!] MD5 CRACKED: $web_result${NC}"
            return 0
        fi
    fi
    
    echo -e "${CYAN}[i] Not found in online databases${NC}"
    return 1
}

# Only attempt online lookup for valid hex hashes
if [[ "$INPUT" =~ ^[0-9a-fA-F]+$ ]] && [ "$LEN" -ge 32 ]; then
    online_lookup "$INPUT"
    echo
fi

# --- JWT DETECTION ---
if [[ "$INPUT" =~ ^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$ ]]; then
    echo -e "${GREEN}[+] Detected: JSON Web Token (JWT)${NC}"
    
    HEADER=$(echo "$INPUT" | cut -d'.' -f1)
    PAYLOAD=$(echo "$INPUT" | cut -d'.' -f2)
    SIGNATURE=$(echo "$INPUT" | cut -d'.' -f3)
    
    decode_base64url() {
        local input="$1"
        input=$(echo "$input" | tr '_-' '/+')
        case $((${#input} % 4)) in
            2) input="${input}==" ;;
            3) input="${input}=" ;;
        esac
        echo "$input" | base64 -d 2>/dev/null
    }
    
    HEADER_JSON=$(decode_base64url "$HEADER")
    PAYLOAD_JSON=$(decode_base64url "$PAYLOAD")
    
    echo -e "${CYAN}   Header:  $HEADER_JSON${NC}"
    echo -e "${CYAN}   Payload: $PAYLOAD_JSON${NC}"
    echo -e "${YELLOW}   Signature: $SIGNATURE${NC}"
    
    if echo "$HEADER_JSON" | grep -qi '"alg"[[:space:]]*:[[:space:]]*"none"'; then
        echo -e "${RED}   [!] VULNERABLE: 'none' algorithm detected!${NC}"
    fi
    
    if echo "$PAYLOAD_JSON" | grep -qiE "(flag|ctf|thm|htb)\{"; then
        FLAG=$(echo "$PAYLOAD_JSON" | grep -oE '(flag|FLAG|ctf|CTF|thm|THM|htb|HTB)\{[^}]+\}')
        echo -e "${GREEN}   [!!!] FLAG FOUND: $FLAG${NC}"
    fi
    
    exit 0
fi

# --- SALTED HASH ANALYSIS ---
if [[ "$INPUT" == *":"* ]]; then
    HASH_PART=$(echo "$INPUT" | cut -d':' -f1)
    SALT_PART=$(echo "$INPUT" | cut -d':' -f2)
    HASH_LEN=${#HASH_PART}
    
    echo -e "${CYAN}[i] Salted hash detected${NC}"
    echo -e "${YELLOW}   Hash: $HASH_PART${NC}"
    echo -e "${YELLOW}   Salt: $SALT_PART${NC}"
    
    if [[ "$HASH_PART" =~ ^[0-9a-fA-F]+$ ]]; then
        case $HASH_LEN in
            32) echo -e "${GREEN}[+] Format: MD5:salt (Hashcat -m 20)${NC}" ;;
            40) echo -e "${GREEN}[+] Format: SHA1:salt (Hashcat -m 110)${NC}" ;;
            64) echo -e "${GREEN}[+] Format: SHA256:salt (Hashcat -m 1410)${NC}" ;;
            128) echo -e "${GREEN}[+] Format: SHA512:salt (Hashcat -m 1710)${NC}" ;;
            *) echo -e "${YELLOW}[!] Unknown salted hash format${NC}" ;;
        esac
    fi
    exit 0
fi

# --- SPECIFIC PATTERNS ---
if [[ "$INPUT" == \$2* ]]; then
    echo -e "${GREEN}[+] Detected: bcrypt (Hashcat -m 3200)${NC}"
    exit 0
fi

if [[ "$INPUT" == \$argon2* ]]; then
    echo -e "${GREEN}[+] Detected: Argon2 (Hashcat -m 19600+)${NC}"
    exit 0
fi

if [[ "$INPUT" == \$1\$* ]]; then
    echo -e "${GREEN}[+] Detected: MD5-Crypt (Hashcat -m 500)${NC}"
    exit 0
fi

if [[ "$INPUT" == \$5\$* ]]; then
    echo -e "${GREEN}[+] Detected: SHA256-Crypt (Hashcat -m 7400)${NC}"
    exit 0
fi

if [[ "$INPUT" == \$6\$* ]]; then
    echo -e "${GREEN}[+] Detected: SHA512-Crypt (Hashcat -m 1800)${NC}"
    exit 0
fi

# --- ENHANCED HASH TYPE DETECTION ---
if [[ "$INPUT" =~ ^[0-9a-fA-F]+$ ]]; then
    echo -e "${CYAN}[i] Format: Hexadecimal${NC}"
    
    # Validate hash length
    if ! validate_hash "$INPUT"; then
        echo -e "${RED}[!] Invalid hash format${NC}"
        exit 1
    fi
    
    CANDIDATES=""
    HASHCAT_MODES=""
    
    case $LEN in
        32)
            CANDIDATES="MD5, NTLM, MD4, LM, RIPEMD-128"
            HASHCAT_MODES="0 (MD5), 1000 (NTLM), 900 (MD4), 3000 (LM)"
            ;;
        40)
            CANDIDATES="SHA1, RIPEMD-160, MySQL5, Tiger-160"
            HASHCAT_MODES="100 (SHA1), 300 (MySQL5)"
            ;;
        48)
            CANDIDATES="Tiger-192, Haval-192"
            HASHCAT_MODES=""
            ;;
        56)
            CANDIDATES="SHA224, SHA3-224, Haval-224"
            HASHCAT_MODES="1300 (SHA224)"
            ;;
        64)
            CANDIDATES="SHA256, SHA3-256, GOST, Haval-256, Blake2s"
            HASHCAT_MODES="1400 (SHA256), 1700 (SHA3-256)"
            ;;
        96)
            CANDIDATES="SHA384, SHA3-384"
            HASHCAT_MODES="10800 (SHA384)"
            ;;
        128)
            CANDIDATES="SHA512, SHA3-512, Whirlpool, Blake2b"
            HASHCAT_MODES="1700 (SHA512), 6000 (RIPEMD-320)"
            ;;
        *)
            CANDIDATES="Unknown length ($LEN chars)"
            HASHCAT_MODES=""
            ;;
    esac
    
    echo -e "${GREEN}[+] Possible Hash Types:${NC} $CANDIDATES"
    
    if [ -n "$HASHCAT_MODES" ]; then
        echo -e "${BLUE}[+] Hashcat Modes:${NC} $HASHCAT_MODES"
    fi
    
    # Suggest hashcat command if available
    if command -v hashcat &>/dev/null; then
        echo
        echo -e "${CYAN}[*] Crack with hashcat:${NC}"
        case $LEN in
            32) echo "    hashcat -m 0 -a 0 hash.txt rockyou.txt" ;;
            40) echo "    hashcat -m 100 -a 0 hash.txt rockyou.txt" ;;
            64) echo "    hashcat -m 1400 -a 0 hash.txt rockyou.txt" ;;
            128) echo "    hashcat -m 1700 -a 0 hash.txt rockyou.txt" ;;
        esac
    fi
else
    echo -e "${YELLOW}[!] Input is not a valid hex string or recognized hash format${NC}"
    
    if [[ "$INPUT" =~ ^[A-Za-z0-9+/=]+$ ]]; then
        echo -e "${CYAN}[i] Matches Base64 alphabet - might be base64-encoded hash${NC}"
        echo "    Try: echo '$INPUT' | base64 -d | xxd"
    fi
fi

echo

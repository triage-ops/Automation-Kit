#!/bin/bash

echo '''
8""""8                                                  8""""8    8"""8                                                                                 
8    " eeeee eeeee  eeeee  e   e eeeee eeeee eeee eeeee      8    8   8 eeeee eeeee    eeeee eeeee    eeeeeee e    e    e   e  e eeeee eeeee eeee e   e 
8e     8  88 8   8  8   8  8   8 8   8   8   8    8   8 eeeee8    8e  8 8  88   8      8  88 8   8    8  8  8 8    8    8   8  8 8   8   8   8  8 8   8 
88     8   8 8eee8e 8eee8e 8e  8 8eee8   8e  8eee 8e  8 88        88  8 8   8   8e     8   8 8e  8    8e 8  8 8eeee8    8e  8  8 8eee8   8e  8e   8eee8 
88   e 8   8 88   8 88   8 88  8 88      88  88   88  8 ""        88  8 8   8   88     8   8 88  8    88 8  8   88      88  8  8 88  8   88  88   88  8 
88eee8 8eee8 88   8 88   8 88ee8 88      88  88ee 88ee8 88        88  8 8eee8   88     8eee8 88  8    88 8  8   88      88ee8ee8 88  8   88  88e8 88  8 
                                                                                                                                                        
'''

# header_fix.sh - BEAST MODE - Advanced File Forensics & Repair v3.0
# Features: Signature hunting, entropy analysis, deep structure validation

set -euo pipefail

# --- COLORS ---
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# --- DEPENDENCY DEFINITIONS ---
REQUIRED_TOOLS=(
    "xxd:xxd"
    "file:file"
    "dd:coreutils"
    "bc:bc"
)

OPTIONAL_TOOLS=(
    "python3:python3"
)

# --- DEPENDENCY CHECK ---
check_dependencies() {
    local missing_required=()
    local missing_optional=()
    local all_good=true
    
    echo -e "${BLUE}[*] Checking dependencies...${NC}"
    
    for entry in "${REQUIRED_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_required+=("$tool ($package)")
            all_good=false
        fi
    done
    
    for entry in "${OPTIONAL_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_optional+=("$tool ($package)")
        fi
    done
    
    if [ "$all_good" = true ] && [ ${#missing_optional[@]} -eq 0 ]; then
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
        return 0
    fi
    
    if [ ${#missing_required[@]} -gt 0 ]; then
        echo -e "${RED}[✗] MISSING REQUIRED DEPENDENCIES:${NC}"
        printf '%s\n' "${missing_required[@]}" | sed 's/^/    /'
        
        local packages=()
        for entry in "${REQUIRED_TOOLS[@]}"; do
            IFS=':' read -r tool package <<< "$entry"
            if ! command -v "$tool" &>/dev/null; then
                packages+=("$package")
            fi
        done
        packages=($(printf '%s\n' "${packages[@]}" | sort -u))
        
        echo -e "\n${YELLOW}Install with:${NC}"
        echo -e "    ${BOLD}sudo apt install ${packages[*]}${NC}\n"
        exit 1
    fi
    
    if [ ${#missing_optional[@]} -gt 0 ]; then
        echo -e "${YELLOW}[!] Missing optional tools:${NC}"
        printf '%s\n' "${missing_optional[@]}" | sed 's/^/    /'
        echo -e "${CYAN}(Python3 needed for advanced features)${NC}\n"
    else
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
    fi
}

check_dependencies

# --- SIGNATURE DATABASE ---
declare -A SIGNATURES=(
    # Images
    ["89504e470d0a1a0a"]="PNG"
    ["ffd8ffe0"]="JPEG (JFIF)"
    ["ffd8ffe1"]="JPEG (Exif)"
    ["ffd8ffe2"]="JPEG (Canon)"
    ["ffd8ffe3"]="JPEG (Samsung)"
    ["ffd8ffe8"]="JPEG (SPIFF)"
    ["ffd8ffdb"]="JPEG (Progressive/Quantization)"
    ["ffd8ffee"]="JPEG (Adobe)"
    ["474946383961"]="GIF89a"
    ["474946383761"]="GIF87a"
    ["424d"]="BMP"
    ["49492a00"]="TIFF (LE)"
    ["4d4d002a"]="TIFF (BE)"
    ["52494646"]="WEBP/WAV/AVI"
    
    # Archives
    ["504b0304"]="ZIP"
    ["504b0506"]="ZIP (Empty)"
    ["526172211a07"]="RAR"
    ["377abcaf271c"]="7-Zip"
    ["1f8b"]="GZIP"
    ["425a68"]="BZIP2"
    
    # Documents
    ["25504446"]="PDF"
    ["d0cf11e0a1b11ae1"]="MS Office"
    
    # Executables
    ["7f454c46"]="ELF"
    ["4d5a"]="PE/DOS"
    
    # Media
    ["000001ba"]="MPEG PS"
    ["000001b3"]="MPEG Video"
)

# --- ARGUMENT PARSING ---
FILE="$1"

if [ -z "$FILE" ]; then
    echo -e "${RED}Usage: $0 <file>${NC}"
    echo "Example: $0 corrupted_image.png"
    exit 1
fi

if [ ! -f "$FILE" ]; then
    echo -e "${RED}[!] File not found: $FILE${NC}"
    exit 1
fi

echo -e "${BLUE}${BOLD}[*] BEAST MODE: Advanced File Analysis${NC}"
echo -e "${BLUE}[*] Target: $FILE${NC}\n"

# --- 1. SIGNATURE HUNTING (SCAN FIRST 4KB) ---
echo -e "${CYAN}${BOLD}=== [1] SIGNATURE HUNTING ===${NC}"
echo -e "${YELLOW}[*] Scanning first 4096 bytes for known signatures...${NC}"

# Read first 4KB
SCAN_SIZE=4096
HEADER_HEX=$(xxd -p -l $SCAN_SIZE "$FILE" | tr -d '\n')

FOUND_SIGNATURES=()

# Hunt for each signature
for sig in "${!SIGNATURES[@]}"; do
    SIG_NAME="${SIGNATURES[$sig]}"
    
    # Search for signature in hex dump
    if [[ "$HEADER_HEX" == *"$sig"* ]]; then
        # Find offset
        SIG_LEN=${#sig}
        OFFSET=0
        
        # Calculate byte offset
        for (( i=0; i<${#HEADER_HEX}; i+=2 )); do
            CHUNK="${HEADER_HEX:i:$SIG_LEN}"
            if [[ "$CHUNK" == "$sig" ]]; then
                OFFSET=$((i / 2))
                break
            fi
        done
        
        FOUND_SIGNATURES+=("$OFFSET:$SIG_NAME:$sig")
        
        if [ $OFFSET -eq 0 ]; then
            echo -e "${GREEN}[✓] Found $SIG_NAME at offset 0 (correct position)${NC}"
        else
            echo -e "${RED}[!!!] Found $SIG_NAME at offset $OFFSET bytes (SHIFTED!)${NC}"
            echo -e "${YELLOW}    Signature: $sig${NC}"
        fi
    fi
done

if [ ${#FOUND_SIGNATURES[@]} -eq 0 ]; then
    echo -e "${YELLOW}[!] No known signatures found in first 4KB${NC}"
fi

# --- 2. ENTROPY CALCULATION ---
echo -e "\n${CYAN}${BOLD}=== [2] ENTROPY ANALYSIS ===${NC}"
echo -e "${YELLOW}[*] Calculating Shannon entropy...${NC}"

if command -v python3 &>/dev/null; then
    ENTROPY=$(python3 <<PYENTROPY
import sys
import math
from collections import Counter

try:
    with open("$FILE", "rb") as f:
        # Read first 64KB for speed
        data = f.read(65536)
    
    if not data:
        print("0.0")
        sys.exit(0)
    
    # Calculate byte frequency
    freq = Counter(data)
    length = len(data)
    
    # Shannon entropy
    entropy = 0
    for count in freq.values():
        p = count / length
        entropy -= p * math.log2(p)
    
    print(f"{entropy:.4f}")
except Exception as e:
    print("0.0")
PYENTROPY
)
    
    echo -e "${GREEN}[*] Entropy: $ENTROPY / 8.0${NC}"
    
    # Assess entropy
    ENTROPY_INT=$(echo "$ENTROPY" | awk '{printf "%.0f", $1}')
    
    if (( $(echo "$ENTROPY > 7.5" | bc -l) )); then
        echo -e "${RED}[!!!] VERY HIGH ENTROPY - Likely encrypted/compressed!${NC}"
        echo -e "${YELLOW}    This may be: Encrypted file, Compressed archive, Random data${NC}"
    elif (( $(echo "$ENTROPY > 6.0" | bc -l) )); then
        echo -e "${YELLOW}[!] High entropy - Possibly compressed or binary${NC}"
    elif (( $(echo "$ENTROPY > 4.0" | bc -l) )); then
        echo -e "${CYAN}[~] Medium entropy - Mixed data${NC}"
    else
        echo -e "${GREEN}[✓] Low entropy - Structured/repetitive data${NC}"
    fi
else
    echo -e "${YELLOW}[!] Python3 not available - skipping entropy${NC}"
fi

# --- 3. DEEP STRUCTURE VALIDATION ---
echo -e "\n${CYAN}${BOLD}=== [3] DEEP STRUCTURE VALIDATION ===${NC}"

# Detect file type
FILE_TYPE=$(file -b "$FILE" | tr '[:upper:]' '[:lower:]')

# PNG Deep Validation
if [[ "$FILE_TYPE" == *"png"* ]] || [[ "$FILE" == *.png ]]; then
    echo -e "${YELLOW}[*] PNG Structure Analysis...${NC}"
    
    if command -v python3 &>/dev/null; then
        python3 - "$FILE" <<'PYPNG'
import struct
import sys

try:
    with open(sys.argv[1], "rb") as f:
        data = f.read()
    
    # Check PNG signature
    if not data.startswith(b'\x89PNG\r\n\x1a\n'):
        print("    ❌ Invalid PNG signature!")
    else:
        print("    ✓ Valid PNG signature")
    
    # Parse chunks
    pos = 8
    chunks = []
    has_ihdr = False
    has_idat = False
    has_iend = False
    
    while pos < len(data) - 12:
        if pos + 8 > len(data):
            break
        
        length = struct.unpack('>I', data[pos:pos+4])[0]
        chunk_type = data[pos+4:pos+8].decode('ascii', errors='ignore')
        chunks.append((chunk_type, length, pos))
        
        if chunk_type == 'IHDR':
            has_ihdr = True
        elif chunk_type == 'IDAT':
            has_idat = True
        elif chunk_type == 'IEND':
            has_iend = True
        
        pos += 12 + length
    
    print(f"    Found {len(chunks)} chunks:")
    for ct, cl, cp in chunks[:10]:
        print(f"      - {ct}: {cl} bytes at offset {cp}")
    
    if len(chunks) > 10:
        print(f"      ... and {len(chunks) - 10} more")
    
    # Critical chunks validation
    if not has_ihdr:
        print("    ❌ CRITICAL: Missing IHDR chunk!")
    else:
        print("    ✓ IHDR chunk present")
    
    if not has_idat:
        print("    ❌ CRITICAL: Missing IDAT chunk (no image data)!")
    else:
        print("    ✓ IDAT chunk present")
    
    if not has_iend:
        print("    ⚠️  WARNING: Missing IEND chunk (truncated file?)")
    else:
        print("    ✓ IEND chunk present")

except Exception as e:
    print(f"    Error: {e}")
PYPNG
    fi

# JPEG Deep Validation
elif [[ "$FILE_TYPE" == *"jpeg"* ]] || [[ "$FILE" == *.jpg ]] || [[ "$FILE" == *.jpeg ]]; then
    echo -e "${YELLOW}[*] JPEG Structure Analysis...${NC}"
    
    # Check SOI and EOI markers
    HEAD_2=$(xxd -p -l 2 "$FILE" | tr -d '\n')
    TAIL_2=$(tail -c 2 "$FILE" | xxd -p | tr -d '\n')
    
    if [[ "$HEAD_2" == "ffd8" ]]; then
        echo -e "    ${GREEN}✓ Valid JPEG SOI marker (FF D8)${NC}"
    else
        echo -e "    ${RED}❌ Invalid JPEG SOI marker${NC}"
    fi
    
    if [[ "$TAIL_2" == "ffd9" ]]; then
        echo -e "    ${GREEN}✓ Valid JPEG EOI marker (FF D9)${NC}"
    else
        echo -e "    ${RED}❌ Missing JPEG EOI marker - File truncated!${NC}"
    fi
    
    # Count segments
    SEGMENT_COUNT=$(xxd -p "$FILE" | tr -d '\n' | grep -o 'ff' | wc -l)
    echo -e "    ${CYAN}Found ~$SEGMENT_COUNT FF markers (segments)${NC}"

# PDF Deep Validation
elif [[ "$FILE_TYPE" == *"pdf"* ]] || [[ "$FILE" == *.pdf ]]; then
    echo -e "${YELLOW}[*] PDF Structure Analysis...${NC}"
    
    # Check header
    HEAD_5=$(head -c 5 "$FILE")
    if [[ "$HEAD_5" == "%PDF-" ]]; then
        VERSION=$(head -c 8 "$FILE" | tail -c 3)
        echo -e "    ${GREEN}✓ Valid PDF header (version $VERSION)${NC}"
    else
        echo -e "    ${RED}❌ Invalid PDF header${NC}"
    fi
    
    # Check for xref table
    if grep -q "xref" "$FILE"; then
        echo -e "    ${GREEN}✓ xref table found${NC}"
    else
        echo -e "    ${RED}❌ Missing xref table - Corrupted PDF!${NC}"
    fi
    
    # Check for %%EOF
    if tail -c 1024 "$FILE" | grep -q "%%EOF"; then
        echo -e "    ${GREEN}✓ EOF marker present${NC}"
    else
        echo -e "    ${RED}❌ Missing %%EOF marker - Truncated!${NC}"
    fi
    
    # Count objects
    OBJ_COUNT=$(grep -c "obj" "$FILE" || echo 0)
    echo -e "    ${CYAN}Found $OBJ_COUNT objects${NC}"

# ZIP Deep Validation
elif [[ "$FILE_TYPE" == *"zip"* ]] || [[ "$FILE" == *.zip ]]; then
    echo -e "${YELLOW}[*] ZIP Structure Analysis...${NC}"
    
    # Check local file header
    if [[ "$HEADER_HEX" == "504b0304"* ]]; then
        echo -e "    ${GREEN}✓ Valid ZIP local file header${NC}"
    else
        echo -e "    ${RED}❌ Invalid ZIP header${NC}"
    fi
    
    # Check for central directory
    if xxd -p "$FILE" | tr -d '\n' | grep -q "504b0102"; then
        echo -e "    ${GREEN}✓ Central directory found${NC}"
    else
        echo -e "    ${YELLOW}⚠️  No central directory - Possible corruption${NC}"
    fi
    
    # Check for end of central directory
    if xxd -p "$FILE" | tr -d '\n' | grep -q "504b0506"; then
        echo -e "    ${GREEN}✓ End of central directory found${NC}"
    else
        echo -e "    ${RED}❌ Missing end marker - Truncated ZIP!${NC}"
    fi

else
    echo -e "${YELLOW}[~] Format-specific validation not available for this file type${NC}"
    echo -e "${CYAN}    Detected: $FILE_TYPE${NC}"
fi

# --- AUTO-CARVING FOR SHIFTED SIGNATURES ---
echo -e "\n${CYAN}${BOLD}=== [4] AUTO-REPAIR ===${NC}"

for entry in "${FOUND_SIGNATURES[@]}"; do
    IFS=':' read -r offset name sig <<< "$entry"
    
    if [ "$offset" -gt 0 ]; then
        echo -e "${YELLOW}[*] Signature '$name' shifted by $offset bytes${NC}"
        
        # Get file extension from name
        case "$name" in
            PNG) ext="png" ;;
            JPEG*) ext="jpg" ;;
            GIF*) ext="gif" ;;
            PDF) ext="pdf" ;;
            ZIP) ext="zip" ;;
            *) ext="bin" ;;
        esac
        
        CARVED_FILE="${FILE%.}_carved_${offset}.${ext}"
        
        echo -e "${CYAN}[*] Carving from offset $offset to: $CARVED_FILE${NC}"
        dd if="$FILE" of="$CARVED_FILE" bs=1 skip=$offset 2>/dev/null
        
        echo -e "${GREEN}[✓] Created: $CARVED_FILE${NC}"
        echo -e "${YELLOW}    Verify with: file $CARVED_FILE${NC}"
    fi
done

# --- 5. HEADER MISMATCH & REPAIR (The Surgeon) ---
echo -e "\n${CYAN}${BOLD}=== [5] HEADER REPAIR ===${NC}"

# Check if we found a valid signature at offset 0
VALID_AT_0=false
for entry in "${FOUND_SIGNATURES[@]}"; do
    IFS=':' read -r offset name sig <<< "$entry"
    if [ "$offset" -eq 0 ]; then
        VALID_AT_0=true
        break
    fi
done

if [ "$VALID_AT_0" = true ]; then
    echo -e "${GREEN}[✓] Header is valid (matches signature at offset 0)${NC}"
else
    echo -e "${YELLOW}[!] No valid signature found at offset 0.${NC}"
    
    # Get expected signature based on extension
    EXT="${FILE##*.}"
    EXT=$(echo "$EXT" | tr '[:upper:]' '[:lower:]')
    
    EXPECTED=""
    case "$EXT" in
        png) EXPECTED="89504e470d0a1a0a" ;;
        jpg|jpeg) EXPECTED="ffd8ffe0" ;;
        gif) EXPECTED="474946383961" ;;
        bmp) EXPECTED="424d" ;;
        pdf) EXPECTED="25504446" ;;
        zip|docx|xlsx|jar) EXPECTED="504b0304" ;;
        rar) EXPECTED="526172211a07" ;;
        7z) EXPECTED="377abcaf271c" ;;
        gz) EXPECTED="1f8b" ;;
        *) EXPECTED="" ;;
    esac
    
    if [ -n "$EXPECTED" ]; then
        echo -e "${CYAN}[*] Extension '.$EXT' expects signature: $EXPECTED${NC}"
        CURRENT_HEADER=$(xxd -p -l $((${#EXPECTED}/2)) "$FILE" | tr -d '\n')
        echo -e "    Current Header: $CURRENT_HEADER"
        
        echo -e "${YELLOW}[?] Attempt Force-Repair? (Overwrites header bytes)${NC}"
        
        # Auto-repair for valid extensions if entropy is reasonable (not 0 or totally empty)
        if [ -s "$FILE" ]; then 
             echo -e "${CYAN}[*] Patching header...${NC}"
             
             # Backup
             cp "$FILE" "${FILE}.bak"
             echo -e "    Backup created: ${FILE}.bak"
             
             # Patch
             echo -n "$EXPECTED" | xxd -r -p | dd of="$FILE" bs=1 count=$((${#EXPECTED}/2)) conv=notrunc 2>/dev/null
             echo -e "${GREEN}[✓] Header patched! Try opening the file now.${NC}"
             
             # Special Fix for PNG CRC if patched
             if [[ "$EXT" == "png" ]] && command -v python3 &>/dev/null; then
                 echo -e "${YELLOW}[*] Recalculating PNG IHDR CRC...${NC}"
                 python3 - "$FILE" <<'PYFIX'
import struct
import binascii
import sys

try:
    with open(sys.argv[1], "rb+") as f:
        f.seek(8)
        chunk_len = struct.unpack(">I", f.read(4))[0]
        chunk_type = f.read(4)
        if chunk_type == b'IHDR':
            data = f.read(chunk_len)
            crc = binascii.crc32(chunk_type + data) & 0xffffffff
            f.write(struct.pack(">I", crc))
            print("    [+] CRC updated")
except:
    pass
PYFIX
             fi
        fi
    else
        echo -e "${YELLOW}[i] No known signature for extension .$EXT${NC}"
    fi
fi

echo -e "\n${GREEN}${BOLD}[✓] ANALYSIS COMPLETE${NC}\n"

#!/bin/bash

echo '''
8    8                                                     8                                    
8    8 eeeee e   e    e   e e  eeeee eeee    e eeeee       8     eeee e  eeeee eeeee    e eeeee 
8eeee8 8  88 8   8    8   8 8  8   8 8       8   8         8e    8    8  8   8 8   8    8   8   
  88   8   8 8e  8    8eee8 8e 8e  8 8eee    8e  8e        88    8eee 8e 8e  8 8e  8    8e  8e  
  88   8   8 88  8    88  8 88 88  8 88      88  88        88    88   88 88  8 88  8    88  88  
  88   8eee8 88ee8    88  8 88 88ee8 88ee    88  88  88    88    88   88 88  8 88ee8    88  88  
                                                                                                
'''

# stego_hunt.sh - Enhanced Steganography Detection & Extraction v2.0
# Unified stego analysis with parallel execution and progress tracking

set -euo pipefail

# --- COLORS ---
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# --- DEPENDENCY DEFINITIONS ---
REQUIRED_TOOLS=(
    "file:file"
    "strings:bin utils"
)

OPTIONAL_TOOLS=(
    "exiftool:libimage-exiftool-perl"
    "binwalk:binwalk"
    "steghide:steghide"
    "zsteg:zsteg"
    "pngcheck:pngcheck"
    "sox:sox"
    "ffmpeg:ffmpeg"
    "stegdetect:stegdetect"
    "outguess:outguess"
    "python3:python3"
    "convert:imagemagick"
    "stegsnow:stegsnow"
    "zbarimg:zbar-tools"
)

# --- ENHANCED DEPENDENCY CHECK ---
check_dependencies() {
    local missing_required=()
    local missing_optional=()
    local all_good=true
    
    echo -e "${BLUE}[*] Checking dependencies...${NC}"
    
    for entry in "${REQUIRED_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_required+=("$tool ($package)")
            all_good=false
        fi
    done
    
    for entry in "${OPTIONAL_TOOLS[@]}"; do
        IFS=':' read -r tool package <<< "$entry"
        if ! command -v "$tool" &>/dev/null; then
            missing_optional+=("$tool ($package)")
        fi
    done
    
    if [ "$all_good" = true ] && [ ${#missing_optional[@]} -eq 0 ]; then
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
        return 0
    fi
    
    if [ ${#missing_required[@]} -gt 0 ]; then
        echo -e "${RED}[✗] MISSING REQUIRED DEPENDENCIES:${NC}"
        printf '%s\n' "${missing_required[@]}" | sed 's/^/    /'
        
        local packages=()
        for entry in "${REQUIRED_TOOLS[@]}"; do
            IFS=':' read -r tool package <<< "$entry"
            if ! command -v "$tool" &>/dev/null; then
                packages+=("$package")
            fi
        done
        packages=($(printf '%s\n' "${packages[@]}" | sort -u))
        
        echo -e "\n${YELLOW}Install with:${NC}"
        echo -e "    ${BOLD}sudo apt install ${packages[*]}${NC}\n"
        exit 1
    fi
    
    if [ ${#missing_optional[@]} -gt 0 ]; then
        echo -e "${YELLOW}[!] Missing optional tools (${#missing_optional[@]} tools):${NC}"
        # Only show first 5 to avoid clutter
        printf '%s\n' "${missing_optional[@]:0:5}" | sed 's/^/    /'
        [ ${#missing_optional[@]} -gt 5 ] && echo "    ... and $((${#missing_optional[@]} - 5)) more"
        
        local opt_packages=()
        for entry in "${OPTIONAL_TOOLS[@]}"; do
            IFS=':' read -r tool package <<< "$entry"
            if ! command -v "$tool" &>/dev/null; then
                opt_packages+=("$package")
            fi
        done
        opt_packages=($(printf '%s\n' "${opt_packages[@]}" | sort -u))
        
        echo -e "\n${CYAN}Install popular tools:${NC}"
        echo -e "    ${BOLD}sudo apt install exiftool binwalk steghide pngcheck sox${NC}"
        echo -e "    ${BOLD}gem install zsteg${NC}\n"
    else
        echo -e "${GREEN}[✓] All dependencies satisfied!${NC}\n"
    fi
}

check_dependencies

# --- ARGUMENT PARSING ---
FILE="$1"
WORDLIST="${2:-}"

if [ -z "$FILE" ]; then
    echo -e "${RED}Usage: $0 <file> [wordlist]${NC}"
    echo "Example: $0 image.png /usr/share/wordlists/rockyou.txt"
    exit 1
fi

if [ ! -f "$FILE" ]; then
    echo -e "${RED}[!] File not found: $FILE${NC}"
    exit 1
fi

# --- PROGRESS INDICATOR ---
show_progress() {
    local task="$1"
    echo -ne "${CYAN}[*] $task...${NC}\r"
}

finish_progress() {
    local task="$1"
    echo -e "${GREEN}[✓] $task${NC}"
}

# --- SETUP ---
OUT_DIR="/tmp/stego_hunt_$$"
mkdir -p "$OUT_DIR"
trap "rm -rf $OUT_DIR" EXIT

echo -e "${BLUE}[*] Results directory: $OUT_DIR${NC}\n"

# --- CACHE FILE TYPE ---
show_progress "Analyzing file"
FILE_TYPE=$(file -b --mime-type "$FILE")
FILE_TYPE_DESC=$(file -b "$FILE")
finish_progress "File type: $FILE_TYPE"

# --- PARALLEL BASIC CHECKS ---
run_basic_checks() {
    if command -v exiftool &>/dev/null; then
        exiftool "$FILE" > "$OUT_DIR/exif.txt" 2>&1 &
    fi
    
    if command -v binwalk &>/dev/null; then
        binwalk "$FILE" > "$OUT_DIR/binwalk.txt" 2>&1 &
    fi
    
    # String extraction
    strings "$FILE" > "$OUT_DIR/strings.txt" 2>&1 &
    
    wait
}

show_progress "Running basic scans"
run_basic_checks
finish_progress "Basic scans complete"

# --- DISPLAY RESULTS ---
echo
echo -e "${BOLD}=== Basic Triage ===${NC}"

if [ -f "$OUT_DIR/strings.txt" ]; then
    echo -e "${YELLOW}[*] Strings (first/last 10):${NC}"
    head -n 10 "$OUT_DIR/strings.txt"
    echo "    ..."
    tail -n 10 "$OUT_DIR/strings.txt"
fi

if [ -f "$OUT_DIR/exif.txt" ]; then
    echo -e "\n${YELLOW}[*] EXIF Metadata:${NC}"
    cat "$OUT_DIR/exif.txt"
fi

if [ -f "$OUT_DIR/binwalk.txt" ]; then
    echo -e "\n${YELLOW}[*] Binwalk Signatures:${NC}"
    cat "$OUT_DIR/binwalk.txt"
fi

echo
echo -e "${BOLD}=== Format-Specific Analysis ===${NC}"

# --- PNG-SPECIFIC ---
if [[ "$FILE_TYPE" == *"png"* ]] || [[ "$FILE" == *.png ]]; then
    echo -e "\n${CYAN}[PNG Analysis]${NC}"
    
    # PNG chunk analysis
    if command -v pngcheck &>/dev/null; then
        show_progress "Checking PNG chunks"
        PNGCHECK_OUT=$(pngcheck -vv "$FILE" 2>&1)
        
        if echo "$PNGCHECK_OUT" | grep -qi "illegal\|invalid\|error\|extra compressed data"; then
            echo -e "${RED}[!!!] PNG ANOMALIES DETECTED!${NC}"
            
            echo "$PNGCHECK_OUT" | grep -i "illegal\|invalid\|error"
            
            if echo "$PNGCHECK_OUT" | grep -qi "extra compressed data"; then
                echo -e "${YELLOW}[!] EXTRA COMPRESSED DATA - FLAG MAY BE HERE!${NC}"
            fi
        else
            finish_progress "PNG structure valid"
        fi
    fi
    
    # zsteg (fast LSB extraction)
    if command -v zsteg &>/dev/null; then
        show_progress "Running zsteg LSB extraction"
        zsteg -a "$FILE" > "$OUT_DIR/zsteg.txt" 2>&1
        
        if grep -qi "flag{\|ctf{\|text:" "$OUT_DIR/zsteg.txt"; then
            echo -e "${GREEN}[!!!] ZSTEG FOUND SOMETHING:${NC}"
            grep -i "flag{\|ctf{\|text:" "$OUT_DIR/zsteg.txt"
        else
            finish_progress "zsteg scan complete"
        fi
    fi
    
    # Bit plane extraction (parallel channels)
    if command -v python3 &>/dev/null; then
        show_progress "Extracting LSB planes"
        python3 <<'PYLSB'
from PIL import Image
import sys

try:
    img = Image.open(sys.argv[1]).convert('RGB')
    width, height = img.size
    pixels = img.load()
    
    for channel, name in enumerate(['Red', 'Green', 'Blue']):
        lsb_img = Image.new('L', (width, height))
        lsb_pixels = lsb_img.load()
        
        for y in range(height):
            for x in range(width):
                lsb = (pixels[x, y][channel] & 1) * 255
                lsb_pixels[x, y] = lsb
        
        lsb_img.save(f"{sys.argv[2]}/lsb_{name.lower()}.png")
except Exception as e:
    pass
PYLSB "$FILE" "$OUT_DIR" 2>/dev/null &
    fi
fi

# --- JPEG-SPECIFIC ---
if [[ "$FILE_TYPE" == *"jpeg"* ]] || [[ "$FILE" == *.jpg ]] || [[ "$FILE" == *.jpeg ]]; then
    echo -e "\n${CYAN}[JPEG Analysis]${NC}"
    
    # Steghide (empty password)
    if command -v steghide &>/dev/null; then
        show_progress "Trying steghide (empty password)"
        if steghide extract -sf "$FILE" -p "" -xf "$OUT_DIR/steghide_out.txt" &>/dev/null; then
            echo -e "${GREEN}[!!!] STEGHIDE EXTRACTED DATA!${NC}"
            echo "    Saved to: $OUT_DIR/steghide_out.txt"
            head -n 10 "$OUT_DIR/steghide_out.txt"
        else
            finish_progress "steghide (empty password) - nothing found"
        fi
    fi
    
    # Stegdetect
    if command -v stegdetect &>/dev/null; then
        show_progress "Running stegdetect"
        STEGDET_OUT=$(stegdetect "$FILE" 2>&1)
        if echo "$STEGDET_OUT" | grep -qv "negative"; then
            echo -e "${YELLOW}[!] Stegdetect found: $STEGDET_OUT${NC}"
        fi
    fi
    
    # Outguess
    if command -v outguess &>/dev/null; then
        show_progress "Trying outguess"
        if outguess -r "$FILE" "$OUT_DIR/outguess.txt" &>/dev/null; then
            if [ -s "$OUT_DIR/outguess.txt" ]; then
                echo -e "${GREEN}[!!!] OUTGUESS EXTRACTED DATA!${NC}"
                head -c 200 "$OUT_DIR/outguess.txt"
            fi
        fi
    fi
fi

# --- AUDIO-SPECIFIC ---
if [[ "$FILE_TYPE" == *"audio"* ]] || [[ "$FILE" == *.wav ]] || [[ "$FILE" == *.mp3 ]] || [[ "$FILE" == *.flac ]]; then
    echo -e "\n${CYAN}[Audio Analysis]${NC}"
    
    SPEC_OUT="$OUT_DIR/spectrogram.png"
    
    # Skip unnecessary conversion
    if [[ "$FILE" == *.wav ]]; then
        INPUT_FILE="$FILE"
    else
        if command -v sox &>/dev/null; then
            show_progress "Converting to WAV"
            INPUT_FILE="$OUT_DIR/temp.wav"
            sox "$FILE" "$INPUT_FILE" 2>/dev/null
        else
            INPUT_FILE="$FILE"
        fi
    fi
    
    # Generate spectrogram
    if command -v sox &>/dev/null; then
        show_progress "Generating spectrogram"
        sox "$INPUT_FILE" -n spectrogram -o "$SPEC_OUT" 2>/dev/null && \
        echo -e "${GREEN}[✓] Spectrogram: $SPEC_OUT${NC}"
    elif command -v ffmpeg &>/dev/null; then
        show_progress "Generating spectrogram (ffmpeg)"
        ffmpeg -i "$FILE" -lavfi showspectrumpic=s=1920x1080:legend=0 "$SPEC_OUT" -y &>/dev/null && \
        echo -e "${GREEN}[✓] Spectrogram: $SPEC_OUT${NC}"
    fi
fi

# --- QR/BARCODE SCANNING ---
if [[ "$FILE_TYPE" == *"image"* ]]; then
    if command -v zbarimg &>/dev/null; then
        show_progress "Scanning for QR codes/barcodes"
        BARCODE_DATA=$(zbarimg --quiet --raw "$FILE" 2>/dev/null)
        
        if [ -n "$BARCODE_DATA" ]; then
            echo -e "${GREEN}[!!!] QR/BARCODE FOUND: ${NC}$BARCODE_DATA"
            
            if echo "$BARCODE_DATA" | grep -qiE "(flag|ctf|thm|htb)\{"; then
                FLAG=$(echo "$BARCODE_DATA" | grep -oE '(flag|FLAG|ctf|CTF)\{[^}]+\}')
                echo -e "${GREEN}[!!!] FLAG IN BARCODE: $FLAG${NC}"
            fi
        fi
    fi
fi

wait  # Wait for background jobs

# --- POLYGLOT DETECTION ---
echo
echo -e "${BOLD}=== Polyglot Detection ===${NC}"
show_progress "Testing multiple formats"

FORMATS=()
[ -n "$(file "$FILE" | grep -i image)" ] && FORMATS+=("Image")
unzip -t "$FILE" &>/dev/null && FORMATS+=("ZIP")
tar -tzf "$FILE" &>/dev/null 2>&1 && FORMATS+=("TAR.GZ")
tar -tjf "$FILE" &>/dev/null 2>&1 && FORMATS+=("TAR.BZ2")
[ "$(head -c 4 "$FILE")" == "%PDF" ] && FORMATS+=("PDF")

if [ ${#FORMATS[@]} -gt 1 ]; then
    echo -e "${RED}[!!!] POLYGLOT DETECTED - Valid as ${#FORMATS[@]} formats:${NC}"
    printf '    - %s\n' "${FORMATS[@]}"
else
    finish_progress "Single format detected"
fi

# --- TEXT FILE WHITESPACE ANALYSIS ---
if file "$FILE" | grep -qi "text"; then
    echo
    echo -e "${BOLD}=== Whitespace Steganography ===${NC}"
    
    if command -v stegsnow &>/dev/null; then
        show_progress "Running stegsnow"
        SNOW_OUT=$(stegsnow "$FILE" 2>&1)
        if [ -n "$SNOW_OUT" ] && [[ "$SNOW_OUT" != *"No hidden message"* ]]; then
            echo -e "${GREEN}[!!!] STEGSNOW FOUND: $SNOW_OUT${NC}"
        fi
    fi
    
    # Analyze trailing whitespace
    TRAILING_SPACES=$(grep -E ' +$' "$FILE" | wc -l)
    TRAILING_TABS=$(grep -E '\t+$' "$FILE" | wc -l)
    
    if [ $TRAILING_SPACES -gt 5 ] || [ $TRAILING_TABS -gt 5 ]; then
        echo -e "${YELLOW}[!] Suspicious trailing whitespace:${NC}"
        echo "    Spaces: $TRAILING_SPACES lines"
        echo "    Tabs: $TRAILING_TABS lines"
        echo -e "    ${CYAN}Try binary encoding: space=0, tab=1${NC}"
    fi
fi

# --- BRUTE FORCE MODE ---
if [ -n "$WORDLIST" ] && [ -f "$WORDLIST" ]; then
    echo
    echo -e "${RED}${BOLD}=== BRUTE FORCE MODE ===${NC}"
    
    WORDLIST_SIZE=$(wc -l < "$WORDLIST")
    echo -e "${YELLOW}[*] Using wordlist: $WORDLIST ($WORDLIST_SIZE passwords)${NC}"
    
    if [[ "$FILE_TYPE" == *"jpeg"* ]] && command -v steghide &>/dev/null; then
        echo -e "${CYAN}[*] Brute-forcing steghide...${NC}"
        
        # Progress counter
        count=0
        while IFS= read -r password; do
            ((count++))
            [ $((count % 1000)) -eq 0 ] && echo -ne "${CYAN}\r    Tried: $count / $WORDLIST_SIZE${NC}"
            
            if steghide extract -sf "$FILE" -p "$password" -xf "$OUT_DIR/cracked.txt" &>/dev/null; then
                echo -e "\n${GREEN}[!!!] PASSWORD FOUND: $password${NC}"
                echo "    Extracted to: $OUT_DIR/cracked.txt"
                head -n 20 "$OUT_DIR/cracked.txt"
                break
            fi
        done < "$WORDLIST"
        
        echo
    fi
fi

echo
echo -e "${GREEN}${BOLD}[✓] Analysis Complete${NC}"
echo -e "${CYAN}Results saved to: $OUT_DIR${NC}"
